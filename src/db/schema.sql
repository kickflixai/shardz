-- MicroShort Database Schema Reference
-- This file is a COPY of the Supabase migration for documentation.
-- The source of truth is supabase/migrations/
-- Do NOT edit this file directly. Edit the migration and copy here.

-- MicroShort Content Hierarchy Schema
-- Migration: 00000000000001_create_content_schema
-- Creates: Series > Seasons > Episodes content hierarchy with profiles
-- Business rules enforced at database level via CHECK constraints and triggers

-- ============================================================================
-- ENUMS
-- ============================================================================

-- Genres enum for consistent categorization
CREATE TYPE genre AS ENUM (
  'drama', 'comedy', 'thriller', 'sci-fi', 'horror',
  'romance', 'action', 'documentary', 'behind-the-scenes',
  'music', 'sports'
);

-- Content status workflow
CREATE TYPE content_status AS ENUM (
  'draft', 'processing', 'ready', 'published', 'archived'
);

-- ============================================================================
-- TABLES
-- ============================================================================

-- Series: top-level content entity
CREATE TABLE public.series (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug TEXT UNIQUE NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  genre genre NOT NULL,
  thumbnail_url TEXT,
  trailer_url TEXT,
  creator_id UUID NOT NULL,  -- FK added after profiles table exists
  status content_status NOT NULL DEFAULT 'draft',
  is_featured BOOLEAN NOT NULL DEFAULT false,
  view_count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Seasons: ordered groupings within a series
CREATE TABLE public.seasons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  series_id UUID NOT NULL REFERENCES public.series(id) ON DELETE CASCADE,
  season_number INTEGER NOT NULL,
  title TEXT,
  description TEXT,
  price_cents INTEGER,  -- creator-set price (NULL = free)
  status content_status NOT NULL DEFAULT 'draft',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Enforce unique season numbers within a series
  UNIQUE (series_id, season_number),

  -- Price must be positive if set
  CHECK (price_cents IS NULL OR price_cents > 0)
);

-- Episodes: individual video content
CREATE TABLE public.episodes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  season_id UUID NOT NULL REFERENCES public.seasons(id) ON DELETE CASCADE,
  episode_number INTEGER NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  duration_seconds INTEGER,  -- set by Mux webhook when asset is ready
  mux_asset_id TEXT,
  mux_playback_id TEXT,
  thumbnail_url TEXT,
  subtitle_url TEXT,          -- WebVTT file URL
  status content_status NOT NULL DEFAULT 'draft',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Enforce unique episode numbers within a season
  UNIQUE (season_id, episode_number),

  -- Episodes must be 1-3 minutes (60-180 seconds) when duration is known
  CHECK (duration_seconds IS NULL OR (duration_seconds >= 60 AND duration_seconds <= 180))
);

-- Profiles: user accounts (extends Supabase Auth)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE,
  display_name TEXT,
  avatar_url TEXT,
  role TEXT NOT NULL DEFAULT 'viewer' CHECK (role IN ('viewer', 'creator', 'admin')),
  bio TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ============================================================================
-- FOREIGN KEYS (added after dependent tables exist)
-- ============================================================================

-- Add foreign key for series.creator_id now that profiles exists
ALTER TABLE public.series
  ADD CONSTRAINT fk_series_creator
  FOREIGN KEY (creator_id) REFERENCES public.profiles(id);

-- ============================================================================
-- TRIGGER FUNCTIONS
-- ============================================================================

-- Season episode count enforcement via trigger
-- (8-70 episodes per season -- enforced on publish, not on insert)
CREATE OR REPLACE FUNCTION check_season_episode_count()
RETURNS TRIGGER AS $$
DECLARE
  episode_count INTEGER;
BEGIN
  IF NEW.status = 'published' THEN
    SELECT COUNT(*) INTO episode_count
    FROM public.episodes
    WHERE season_id = NEW.id AND status = 'published';

    IF episode_count < 8 OR episode_count > 70 THEN
      RAISE EXCEPTION 'Published seasons must have 8-70 published episodes (found %)', episode_count;
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_season_episode_count
  BEFORE UPDATE ON public.seasons
  FOR EACH ROW
  WHEN (NEW.status = 'published')
  EXECUTE FUNCTION check_season_episode_count();

-- Updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply updated_at trigger to all content tables
CREATE TRIGGER series_updated_at BEFORE UPDATE ON public.series
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER seasons_updated_at BEFORE UPDATE ON public.seasons
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER episodes_updated_at BEFORE UPDATE ON public.episodes
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER profiles_updated_at BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- ============================================================================
-- ROW LEVEL SECURITY
-- ============================================================================

-- Enable RLS on all content tables
ALTER TABLE public.series ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.seasons ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.episodes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Public read access for published content
CREATE POLICY "Published series are visible to everyone"
  ON public.series FOR SELECT
  USING (status = 'published');

CREATE POLICY "Published seasons are visible to everyone"
  ON public.seasons FOR SELECT
  USING (status = 'published');

CREATE POLICY "Published episodes are visible to everyone"
  ON public.episodes FOR SELECT
  USING (status = 'published');

CREATE POLICY "Profiles are visible to everyone"
  ON public.profiles FOR SELECT
  USING (true);

-- Creators can manage their own series
CREATE POLICY "Creators can manage own series"
  ON public.series FOR ALL
  USING ((SELECT auth.uid()) = creator_id);

-- Creators can manage seasons/episodes in their series
CREATE POLICY "Creators can manage own seasons"
  ON public.seasons FOR ALL
  USING (
    series_id IN (
      SELECT id FROM public.series WHERE creator_id = (SELECT auth.uid())
    )
  );

CREATE POLICY "Creators can manage own episodes"
  ON public.episodes FOR ALL
  USING (
    season_id IN (
      SELECT s.id FROM public.seasons s
      JOIN public.series sr ON s.series_id = sr.id
      WHERE sr.creator_id = (SELECT auth.uid())
    )
  );

-- Users can manage their own profile
CREATE POLICY "Users can manage own profile"
  ON public.profiles FOR ALL
  USING ((SELECT auth.uid()) = id);

-- ============================================================================
-- INDEXES
-- ============================================================================

CREATE INDEX idx_series_genre ON public.series(genre) WHERE status = 'published';
CREATE INDEX idx_series_creator ON public.series(creator_id);
CREATE INDEX idx_series_featured ON public.series(is_featured) WHERE status = 'published';
CREATE INDEX idx_seasons_series ON public.seasons(series_id);
CREATE INDEX idx_episodes_season ON public.episodes(season_id);
CREATE INDEX idx_profiles_role ON public.profiles(role);

-- ============================================================================
-- PURCHASES & PRICING (Migration 00000000000003)
-- ============================================================================

-- Price tiers: preset pricing options for seasons
CREATE TABLE public.price_tiers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  label TEXT NOT NULL,
  price_cents INTEGER NOT NULL CHECK (price_cents > 0),
  stripe_price_id TEXT,
  sort_order INTEGER NOT NULL DEFAULT 0,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.price_tiers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Active price tiers are visible to everyone"
  ON public.price_tiers FOR SELECT
  USING (is_active = true);

-- Seed initial price tiers
INSERT INTO public.price_tiers (label, price_cents, sort_order) VALUES
  ('Budget',      299, 1),
  ('Standard',    499, 2),
  ('Premium',     799, 3),
  ('Deluxe',      999, 4),
  ('Blockbuster', 1499, 5);

-- Seasons: link to price tiers
ALTER TABLE public.seasons
  ADD COLUMN price_tier_id UUID REFERENCES public.price_tiers(id);

-- Profiles: Stripe Connect fields
ALTER TABLE public.profiles
  ADD COLUMN stripe_account_id TEXT,
  ADD COLUMN stripe_onboarding_complete BOOLEAN NOT NULL DEFAULT false;

-- Series: bundle discount percentage
ALTER TABLE public.series
  ADD COLUMN bundle_discount_percent INTEGER DEFAULT 15
    CHECK (bundle_discount_percent IS NULL OR (bundle_discount_percent >= 0 AND bundle_discount_percent <= 50));

-- Purchases: records of completed season unlocks
CREATE TABLE public.purchases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  season_id UUID NOT NULL REFERENCES public.seasons(id),
  creator_id UUID NOT NULL REFERENCES public.profiles(id),
  stripe_session_id TEXT UNIQUE NOT NULL,
  stripe_payment_intent_id TEXT,
  stripe_charge_id TEXT,
  amount_cents INTEGER NOT NULL,
  platform_fee_cents INTEGER NOT NULL,
  creator_share_cents INTEGER NOT NULL,
  status TEXT NOT NULL DEFAULT 'completed'
    CHECK (status IN ('completed', 'refunded')),
  transferred BOOLEAN NOT NULL DEFAULT false,
  stripe_transfer_id TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  UNIQUE (user_id, season_id)
);

ALTER TABLE public.purchases ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own purchases"
  ON public.purchases FOR SELECT
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Creators can view purchases of their content"
  ON public.purchases FOR SELECT
  USING ((SELECT auth.uid()) = creator_id);

CREATE INDEX idx_purchases_user ON public.purchases(user_id);
CREATE INDEX idx_purchases_season ON public.purchases(season_id);
CREATE INDEX idx_purchases_creator ON public.purchases(creator_id);
CREATE INDEX idx_purchases_untransferred ON public.purchases(creator_id)
  WHERE transferred = false;

-- Payout records: tracks completed transfers to creator Connect accounts
CREATE TABLE public.payout_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  creator_id UUID NOT NULL REFERENCES public.profiles(id),
  purchase_id UUID NOT NULL REFERENCES public.purchases(id),
  stripe_transfer_id TEXT NOT NULL,
  amount_cents INTEGER NOT NULL,
  status TEXT NOT NULL DEFAULT 'completed'
    CHECK (status IN ('completed', 'failed')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.payout_records ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Creators can view own payouts"
  ON public.payout_records FOR SELECT
  USING ((SELECT auth.uid()) = creator_id);

CREATE INDEX idx_payouts_creator ON public.payout_records(creator_id);

-- ============================================================================
-- CREATOR DASHBOARD (Migration 00000000000004)
-- ============================================================================

-- Creator Applications
CREATE TABLE public.creator_applications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) UNIQUE,
  display_name TEXT NOT NULL,
  bio TEXT NOT NULL,
  portfolio_url TEXT,
  portfolio_description TEXT NOT NULL,
  sample_video_urls TEXT[] DEFAULT '{}',
  social_links JSONB DEFAULT '{}',
  status TEXT NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'approved', 'rejected')),
  reviewer_notes TEXT,
  reviewed_at TIMESTAMPTZ,
  reviewed_by UUID REFERENCES public.profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.creator_applications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own application"
  ON public.creator_applications FOR SELECT
  USING ((SELECT auth.uid()) = user_id);

CREATE POLICY "Users can insert own application"
  ON public.creator_applications FOR INSERT
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Admins can manage all applications"
  ON public.creator_applications FOR ALL
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = (SELECT auth.uid()) AND role = 'admin')
  );

CREATE TRIGGER creator_applications_updated_at
  BEFORE UPDATE ON public.creator_applications
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE INDEX idx_applications_status ON public.creator_applications(status);
CREATE INDEX idx_applications_user ON public.creator_applications(user_id);

-- Seasons: release strategy + sort order
ALTER TABLE public.seasons
  ADD COLUMN release_strategy TEXT NOT NULL DEFAULT 'all_at_once'
    CHECK (release_strategy IN ('all_at_once', 'drip')),
  ADD COLUMN drip_interval_days INTEGER DEFAULT 7
    CHECK (drip_interval_days IS NULL OR (drip_interval_days >= 1 AND drip_interval_days <= 30)),
  ADD COLUMN sort_order INTEGER NOT NULL DEFAULT 0;

-- Episodes: sort order + content warnings + release date
ALTER TABLE public.episodes
  ADD COLUMN sort_order INTEGER NOT NULL DEFAULT 0,
  ADD COLUMN content_warnings TEXT,
  ADD COLUMN release_date TIMESTAMPTZ;

-- Profiles: social links + follower count
ALTER TABLE public.profiles
  ADD COLUMN social_links JSONB DEFAULT '{}',
  ADD COLUMN follower_count INTEGER NOT NULL DEFAULT 0;

-- Community Posts
CREATE TABLE public.community_posts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  series_id UUID NOT NULL REFERENCES public.series(id) ON DELETE CASCADE,
  author_id UUID NOT NULL REFERENCES public.profiles(id),
  content TEXT NOT NULL CHECK (char_length(content) <= 1000),
  post_type TEXT NOT NULL DEFAULT 'discussion'
    CHECK (post_type IN ('discussion', 'poll', 'announcement')),
  poll_options JSONB,
  is_pinned BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.community_posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Community posts are publicly readable"
  ON public.community_posts FOR SELECT USING (true);

CREATE POLICY "Authenticated users can create posts"
  ON public.community_posts FOR INSERT
  WITH CHECK ((SELECT auth.uid()) IS NOT NULL);

CREATE POLICY "Authors can update own posts"
  ON public.community_posts FOR UPDATE
  USING ((SELECT auth.uid()) = author_id);

CREATE POLICY "Authors and series creators can delete posts"
  ON public.community_posts FOR DELETE
  USING (
    (SELECT auth.uid()) = author_id OR
    EXISTS (
      SELECT 1 FROM public.series
      WHERE id = series_id AND creator_id = (SELECT auth.uid())
    )
  );

CREATE TRIGGER community_posts_updated_at
  BEFORE UPDATE ON public.community_posts
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE INDEX idx_community_posts_series ON public.community_posts(series_id);
CREATE INDEX idx_community_posts_author ON public.community_posts(author_id);

-- Poll Votes
CREATE TABLE public.poll_votes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID NOT NULL REFERENCES public.community_posts(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  option_index INTEGER NOT NULL CHECK (option_index >= 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (post_id, user_id)
);

ALTER TABLE public.poll_votes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Votes are publicly readable"
  ON public.poll_votes FOR SELECT USING (true);

CREATE POLICY "Authenticated users can vote"
  ON public.poll_votes FOR INSERT
  WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE INDEX idx_poll_votes_post ON public.poll_votes(post_id);

-- Followers
CREATE TABLE public.followers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  follower_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  creator_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (follower_id, creator_id)
);

ALTER TABLE public.followers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Follows are publicly readable"
  ON public.followers FOR SELECT USING (true);

CREATE POLICY "Users can follow creators"
  ON public.followers FOR INSERT
  WITH CHECK ((SELECT auth.uid()) = follower_id);

CREATE POLICY "Users can unfollow"
  ON public.followers FOR DELETE
  USING ((SELECT auth.uid()) = follower_id);

CREATE INDEX idx_followers_creator ON public.followers(creator_id);
CREATE INDEX idx_followers_follower ON public.followers(follower_id);

-- Follower count trigger
CREATE OR REPLACE FUNCTION update_follower_count()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.profiles SET follower_count = follower_count + 1 WHERE id = NEW.creator_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.profiles SET follower_count = follower_count - 1 WHERE id = OLD.creator_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER followers_count_insert
  AFTER INSERT ON public.followers
  FOR EACH ROW EXECUTE FUNCTION update_follower_count();

CREATE TRIGGER followers_count_delete
  AFTER DELETE ON public.followers
  FOR EACH ROW EXECUTE FUNCTION update_follower_count();

-- ============================================================================
-- ADMIN PANEL (Migration 00000000000005)
-- ============================================================================

-- Featured series sort order for homepage curation
ALTER TABLE public.series
  ADD COLUMN featured_sort_order INTEGER DEFAULT 0;

-- Editorial picks: curated collections for homepage sections
CREATE TABLE public.editorial_picks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  series_id UUID NOT NULL REFERENCES public.series(id) ON DELETE CASCADE,
  section TEXT NOT NULL DEFAULT 'featured'
    CHECK (section IN ('featured', 'trending', 'new_releases', 'staff_picks')),
  sort_order INTEGER NOT NULL DEFAULT 0,
  added_by UUID REFERENCES public.profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (series_id, section)
);

ALTER TABLE public.editorial_picks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Editorial picks are publicly readable"
  ON public.editorial_picks FOR SELECT
  USING (true);

CREATE POLICY "Admins can manage editorial picks"
  ON public.editorial_picks FOR ALL
  USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = (SELECT auth.uid()) AND role = 'admin')
  );

CREATE INDEX idx_editorial_picks_section ON public.editorial_picks(section, sort_order);

-- Admin RLS policies (defense-in-depth; admin panel uses createAdminClient() which bypasses RLS)
CREATE POLICY "Admins can manage all series"
  ON public.series FOR ALL
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = (SELECT auth.uid()) AND role = 'admin'));

CREATE POLICY "Admins can manage all seasons"
  ON public.seasons FOR ALL
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = (SELECT auth.uid()) AND role = 'admin'));

CREATE POLICY "Admins can manage all episodes"
  ON public.episodes FOR ALL
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = (SELECT auth.uid()) AND role = 'admin'));

CREATE POLICY "Admins can manage all profiles"
  ON public.profiles FOR ALL
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = (SELECT auth.uid()) AND role = 'admin'));

CREATE POLICY "Admins can view all purchases"
  ON public.purchases FOR SELECT
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = (SELECT auth.uid()) AND role = 'admin'));

CREATE POLICY "Admins can manage all community posts"
  ON public.community_posts FOR ALL
  USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = (SELECT auth.uid()) AND role = 'admin'));

-- Storage bucket for thumbnails
INSERT INTO storage.buckets (id, name, public) VALUES ('thumbnails', 'thumbnails', true);

CREATE POLICY "Creators can upload thumbnails"
  ON storage.objects FOR INSERT
  WITH CHECK (
    bucket_id = 'thumbnails' AND
    auth.uid()::text = (storage.foldername(name))[1]
  );

CREATE POLICY "Creators can update own thumbnails"
  ON storage.objects FOR UPDATE
  USING (bucket_id = 'thumbnails' AND auth.uid()::text = (storage.foldername(name))[1]);

CREATE POLICY "Creators can delete own thumbnails"
  ON storage.objects FOR DELETE
  USING (bucket_id = 'thumbnails' AND auth.uid()::text = (storage.foldername(name))[1]);

CREATE POLICY "Thumbnails are publicly readable"
  ON storage.objects FOR SELECT
  USING (bucket_id = 'thumbnails');
