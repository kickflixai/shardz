---
phase: 02-authentication-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/validations/auth.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/login/actions.ts
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/signup/actions.ts
  - src/app/auth/confirm/route.ts
  - src/components/auth/logout-button.tsx
  - src/components/layout/header.tsx
  - src/components/layout/mobile-nav.tsx
  - supabase/migrations/00000000000002_auth_profile_trigger.sql
autonomous: true

must_haves:
  truths:
    - "User can sign up with email and password and see a confirmation message"
    - "User can log in with valid credentials and be redirected to home"
    - "User can log out from the header on any page"
    - "User session persists across browser refresh (cookie-based via middleware)"
    - "Auth email links (confirmation, recovery) land on a working callback handler that exchanges tokens"
    - "A profile row is automatically created in public.profiles when a new user signs up"
  artifacts:
    - path: "src/lib/validations/auth.ts"
      provides: "Zod schemas for login, signup, forgot-password, reset-password"
      exports: ["loginSchema", "signupSchema", "forgotPasswordSchema", "resetPasswordSchema", "AuthFormState"]
    - path: "src/app/(auth)/login/actions.ts"
      provides: "Login server action"
      exports: ["login"]
    - path: "src/app/(auth)/signup/actions.ts"
      provides: "Signup server action"
      exports: ["signup"]
    - path: "src/app/auth/confirm/route.ts"
      provides: "PKCE token exchange callback"
      exports: ["GET"]
    - path: "src/components/auth/logout-button.tsx"
      provides: "Logout button component"
      exports: ["LogoutButton"]
    - path: "supabase/migrations/00000000000002_auth_profile_trigger.sql"
      provides: "handle_new_user trigger for auto profile creation"
      contains: "CREATE TRIGGER on_auth_user_created"
  key_links:
    - from: "src/app/(auth)/login/page.tsx"
      to: "src/app/(auth)/login/actions.ts"
      via: "useActionState + form action"
      pattern: "useActionState.*login"
    - from: "src/app/(auth)/signup/page.tsx"
      to: "src/app/(auth)/signup/actions.ts"
      via: "useActionState + form action"
      pattern: "useActionState.*signup"
    - from: "src/app/(auth)/login/actions.ts"
      to: "supabase.auth.signInWithPassword"
      via: "server action calling Supabase Auth"
      pattern: "signInWithPassword"
    - from: "src/app/(auth)/signup/actions.ts"
      to: "supabase.auth.signUp"
      via: "server action calling Supabase Auth"
      pattern: "auth\\.signUp"
    - from: "src/components/layout/header.tsx"
      to: "src/components/auth/logout-button.tsx"
      via: "conditional render based on auth state"
      pattern: "LogoutButton"
    - from: "src/app/auth/confirm/route.ts"
      to: "supabase.auth.verifyOtp"
      via: "token_hash exchange"
      pattern: "verifyOtp"
---

<objective>
Set up Supabase Auth with email/password signup, login, logout, session persistence, and automatic profile creation. Replace the Phase 1 placeholder login/signup pages with functional auth forms using server actions and Zod validation.

Purpose: Users can create accounts and authenticate -- the foundation for all access control, content gating, and personalized features in later phases.
Output: Working login, signup, and logout flows; auth callback handler for email links; profile auto-creation trigger; Zod validation schemas shared across auth forms.
</objective>

<execution_context>
@/Users/solofilms/.claude/get-shit-done/workflows/execute-plan.md
@/Users/solofilms/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-access/02-RESEARCH.md
@.planning/phases/01-foundation-app-shell/01-01-SUMMARY.md
@.planning/phases/01-foundation-app-shell/01-02-SUMMARY.md
@.planning/phases/01-foundation-app-shell/01-03-SUMMARY.md
@src/lib/supabase/server.ts
@src/lib/supabase/client.ts
@src/lib/supabase/middleware.ts
@src/middleware.ts
@src/app/(auth)/layout.tsx
@src/components/layout/header.tsx
@src/components/layout/mobile-nav.tsx
@supabase/config.toml
@supabase/migrations/00000000000001_create_content_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, create Zod schemas, database trigger, and auth callback</name>
  <files>
    src/lib/validations/auth.ts
    supabase/migrations/00000000000002_auth_profile_trigger.sql
    src/app/auth/confirm/route.ts
    .env.example
  </files>
  <action>
**Step 1: Install zod and shadcn/ui form components.**

```bash
pnpm add zod
pnpm dlx shadcn@latest add button card input label field
```

Note: shadcn CLI v3.x auto-detects the project config. If prompted for overwrite on existing components, accept. These components land in `src/components/ui/`.

**Step 2: Create Zod validation schemas at `src/lib/validations/auth.ts`.**

Export the following schemas and types:
- `loginSchema`: email (valid email), password (min 6 chars)
- `signupSchema`: email (valid email), password (min 6, max 72), displayName (min 2, max 50, optional)
- `forgotPasswordSchema`: email (valid email)
- `resetPasswordSchema`: password (min 6, max 72), confirmPassword -- with `.refine()` to check passwords match (error on `confirmPassword` path)
- Export `type LoginInput`, `SignupInput`, `ForgotPasswordInput`, `ResetPasswordInput` via `z.infer`
- Export `AuthFormState` type used by all server actions:
  ```typescript
  export type AuthFormState = {
    values?: Record<string, string>
    errors: Record<string, string[]> | null
    success: boolean
    message?: string
  }
  ```

Follow Biome conventions: tabs, double quotes, semicolons.

**Step 3: Create the `handle_new_user` database trigger migration.**

File: `supabase/migrations/00000000000002_auth_profile_trigger.sql`

This trigger automatically creates a `public.profiles` row when a new user is inserted into `auth.users`. The profiles table already exists from migration 00000000000001.

```sql
-- Auto-create profile on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.profiles (id, display_name)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'display_name');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();
```

Key details:
- `SECURITY DEFINER` so the function can write to `public.profiles` regardless of caller permissions
- `SET search_path = ''` with explicit `public.` schema references for security
- `display_name` is nullable in the profiles table, so this works even without a displayName
- Only `id` and `display_name` are set; `role` defaults to `'viewer'`, timestamps default to `now()`

**Step 4: Create the auth callback route handler at `src/app/auth/confirm/route.ts`.**

This is the PKCE token exchange endpoint. Email links (signup confirmation, password reset) redirect here with `token_hash` and `type` query params.

```typescript
import { type EmailOtpType } from "@supabase/supabase-js";
import { type NextRequest } from "next/server";
import { redirect } from "next/navigation";
import { createClient } from "@/lib/supabase/server";

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const token_hash = searchParams.get("token_hash");
  const type = searchParams.get("type") as EmailOtpType | null;
  const next = searchParams.get("next") ?? "/";

  if (token_hash && type) {
    const supabase = await createClient();
    const { error } = await supabase.auth.verifyOtp({ type, token_hash });

    if (!error) {
      if (type === "recovery") {
        redirect("/reset-password");
      }
      redirect(next);
    }
  }

  redirect("/auth-code-error");
}
```

**Step 5: Add `NEXT_PUBLIC_SITE_URL` to `.env.example`.**

Append to the existing file:
```
NEXT_PUBLIC_SITE_URL=http://localhost:3000
```

This is used by signup and password reset server actions for constructing email redirect URLs.
  </action>
  <verify>
- `pnpm build` compiles without errors (validates TypeScript types, imports)
- `src/lib/validations/auth.ts` exports all 4 schemas + AuthFormState type
- `supabase/migrations/00000000000002_auth_profile_trigger.sql` exists and contains `CREATE TRIGGER on_auth_user_created`
- `src/app/auth/confirm/route.ts` exports a GET function
- `src/components/ui/button.tsx`, `card.tsx`, `input.tsx`, `label.tsx`, `field.tsx` exist (from shadcn)
- `.env.example` contains `NEXT_PUBLIC_SITE_URL`
  </verify>
  <done>Zod schemas validate auth form inputs, the database trigger creates profiles on signup, the auth callback handler exchanges PKCE tokens, shadcn form components are available, and NEXT_PUBLIC_SITE_URL is documented.</done>
</task>

<task type="auto">
  <name>Task 2: Build auth forms (login, signup, logout) and update header with auth state</name>
  <files>
    src/app/(auth)/login/page.tsx
    src/app/(auth)/login/actions.ts
    src/app/(auth)/signup/page.tsx
    src/app/(auth)/signup/actions.ts
    src/components/auth/logout-button.tsx
    src/components/layout/header.tsx
    src/components/layout/mobile-nav.tsx
  </files>
  <action>
**Step 1: Create login server action at `src/app/(auth)/login/actions.ts`.**

```typescript
"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { createClient } from "@/lib/supabase/server";
import { loginSchema, type AuthFormState } from "@/lib/validations/auth";
```

The `login` function:
- Signature: `async function login(_prevState: AuthFormState, formData: FormData): Promise<AuthFormState>`
- Extract `email` and `password` from formData
- Validate with `loginSchema.safeParse()`
- On validation failure: return `{ values: { email }, errors: result.error.flatten().fieldErrors, success: false }`
- On pass: call `supabase.auth.signInWithPassword({ email, password })`
- On auth error: return `{ values: { email }, errors: null, success: false, message: "Invalid email or password" }` (generic message to prevent email enumeration)
- On success: `revalidatePath("/", "layout")` then `redirect("/")`

**Step 2: Replace the login page placeholder at `src/app/(auth)/login/page.tsx`.**

Make this a `"use client"` component. Import `useActionState` from `"react"`. Import `login` from `./actions`. Import shadcn components: `Button`, `Card`/`CardHeader`/`CardTitle`/`CardDescription`/`CardContent`/`CardFooter`, `Input`, `Label`, `Field`/`FieldError`.

Structure:
- Use `useActionState(login, initialState)` where initialState has `errors: null, success: false`
- `<Card>` wrapper with `<CardHeader>` containing title "Sign In" and description "Sign in to your MicroShort account"
- `<CardContent>` with `<form action={formAction}>`:
  - Email field: `<Field>` with `<Label>` + `<Input type="email" name="email" required defaultValue={state.values?.email}>` + `<FieldError>` showing `state.errors?.email`
  - Password field: same pattern with `type="password" name="password" required`
  - General error message (state.message) displayed in a styled div above submit
  - Submit `<Button type="submit" className="w-full">` with text "Sign In", disabled during pending (`useFormStatus` or check pending from useActionState)
- `<CardFooter>` with link to `/signup` ("Don't have an account? Sign up") and link to `/forgot-password` ("Forgot password?")

Use `useActionState` third argument for permalink if needed by Next.js 16 (check if it requires it). The standard pattern is `const [state, formAction, isPending] = useActionState(login, initialState)`.

**Step 3: Create signup server action at `src/app/(auth)/signup/actions.ts`.**

Similar to login but:
- Extract `email`, `password`, `displayName` from formData
- Validate with `signupSchema.safeParse()`
- Call `supabase.auth.signUp({ email, password, options: { data: { display_name: displayName }, emailRedirectTo: \`\${process.env.NEXT_PUBLIC_SITE_URL}/auth/confirm\` } })`
- On auth error: return with `error.message`
- On success: do NOT redirect. Return `{ errors: null, success: true, message: "Check your email for a confirmation link." }`
- Note: With `enable_confirmations = false` in dev config.toml, the user is auto-confirmed. The success message still works -- it just means the user can immediately log in. The email confirmation flow is still built and ready for when confirmations are enabled.

**Step 4: Replace the signup page placeholder at `src/app/(auth)/signup/page.tsx`.**

Same `"use client"` + `useActionState` pattern as login page.

Structure:
- `<Card>` with title "Create Account", description "Join MicroShort as a viewer or creator"
- Form fields: email, password, displayName (optional, type text)
- Show success message when `state.success` is true (green-tinted div with the message)
- Link to `/login` ("Already have an account? Sign in")

**Step 5: Create the LogoutButton component at `src/components/auth/logout-button.tsx`.**

```typescript
"use client";

import { createClient } from "@/lib/supabase/client";
import { useRouter } from "next/navigation";

export function LogoutButton() {
  const router = useRouter();

  async function handleLogout() {
    const supabase = createClient();
    await supabase.auth.signOut();
    router.push("/");
    router.refresh();
  }

  return (
    <button
      type="button"
      onClick={handleLogout}
      className="text-sm text-muted-foreground transition-colors hover:text-primary"
    >
      Sign Out
    </button>
  );
}
```

**Step 6: Update the header component at `src/components/layout/header.tsx`.**

The existing header always shows a "Sign In" link. Update it to:
- Import `{ useState, useEffect }` from react, `createClient` from `@/lib/supabase/client`, `LogoutButton`, and `User` type from `@supabase/supabase-js`
- Add state: `const [user, setUser] = useState<User | null>(null)`
- Create supabase client: `const supabase = createClient()`
- In `useEffect`:
  - Get initial user: `supabase.auth.getUser().then(({ data }) => setUser(data.user))`
  - Subscribe to auth changes: `supabase.auth.onAuthStateChange((_event, session) => setUser(session?.user ?? null))`
  - Return cleanup: `subscription.unsubscribe()`
  - Dependency array: `[]` (supabase client is stable, created outside component or use useMemo -- or just create inside useEffect)
- Desktop nav: conditionally render `<LogoutButton />` when user exists, or `<Link href="/login">Sign In</Link>` when no user
- Keep existing Home and Browse links unchanged

**Step 7: Update the mobile nav at `src/components/layout/mobile-nav.tsx`.**

Same auth-aware pattern:
- Import `{ useState, useEffect }`, `createClient`, `LogoutButton`, `User` type
- Add user state and auth listener (same pattern as header)
- When user exists: show "Sign Out" button (using LogoutButton) instead of Sign In / Create Account links
- When no user: show existing Sign In and Create Account links

Important: Both header and mobile-nav are `"use client"` components already. The supabase browser client is used for client-side auth state detection via `onAuthStateChange`.
  </action>
  <verify>
- `pnpm build` compiles without errors
- Login page at `/login` renders a form with email, password fields and submit button (replace placeholder)
- Signup page at `/signup` renders a form with email, password, displayName fields (replace placeholder)
- `src/app/(auth)/login/actions.ts` exports `login` function
- `src/app/(auth)/signup/actions.ts` exports `signup` function
- `src/components/auth/logout-button.tsx` exports `LogoutButton`
- Header conditionally renders Sign In or Sign Out based on user state
- Mobile nav conditionally renders Sign In/Create Account or Sign Out based on user state
  </verify>
  <done>Users can sign up with email/password (with Zod validation and error display), log in with credentials, and log out from the header. The header and mobile nav show appropriate auth state. Session persists across refresh via the existing middleware cookie refresh.</done>
</task>

</tasks>

<verification>
1. Navigate to `/signup` -- form renders with email, password, display name fields
2. Submit signup with invalid email -- validation error appears
3. Submit signup with valid data -- success message or auto-login (depending on confirmation setting)
4. Navigate to `/login` -- form renders with email, password fields
5. Submit login with wrong password -- "Invalid email or password" error appears
6. Submit login with correct credentials -- redirected to `/`
7. Header shows "Sign Out" instead of "Sign In" when logged in
8. Click "Sign Out" -- redirected to `/`, header shows "Sign In" again
9. Refresh the page while logged in -- session persists (still shows "Sign Out")
10. Visit `/auth/confirm?token_hash=invalid&type=email` -- redirects to `/auth-code-error`
11. `pnpm build` passes with no errors
</verification>

<success_criteria>
- Login form validates input and authenticates against Supabase Auth
- Signup form creates a new user with optional display name and automatic profile creation
- Logout clears the session and refreshes the UI
- Auth callback handler at `/auth/confirm` exchanges PKCE tokens
- Header and mobile nav reflect current auth state in real time
- All forms use server actions with Zod validation and useActionState
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-access/02-01-SUMMARY.md`
</output>
