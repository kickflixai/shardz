---
phase: 09-social-engagement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00000000000007_social_engagement.sql
  - src/db/types.ts
  - src/db/schema.sql
  - src/lib/validations/social.ts
  - src/lib/moderation/profanity.ts
  - src/modules/social/actions/favorites.ts
  - src/modules/social/actions/watch-history.ts
  - src/modules/social/actions/comments.ts
  - src/modules/social/actions/reactions.ts
  - src/modules/social/actions/profile.ts
  - src/modules/social/actions/report.ts
  - src/modules/social/queries/get-user-favorites.ts
  - src/modules/social/queries/get-watch-history.ts
  - src/modules/social/queries/get-episode-comments.ts
  - src/modules/social/queries/get-episode-reactions.ts
  - src/modules/social/queries/get-user-activity.ts
  - src/components/profile/avatar-upload.tsx
autonomous: true

must_haves:
  truths:
    - "Database tables for episode_comments, episode_reactions, favorites, and watch_history exist with RLS policies"
    - "Profanity filter detects and rejects inappropriate comment content"
    - "Server actions for favorites, watch history, comments, reactions, profile update, and reporting are functional"
    - "Avatar upload stores images in Supabase Storage and updates profile"
  artifacts:
    - path: "supabase/migrations/00000000000007_social_engagement.sql"
      provides: "All Phase 9 database tables, RLS policies, increment_reaction RPC, avatars storage bucket"
      contains: "CREATE TABLE public.episode_comments"
    - path: "src/lib/moderation/profanity.ts"
      provides: "Profanity detection using obscenity library"
      exports: ["containsProfanity", "censorText"]
    - path: "src/modules/social/actions/favorites.ts"
      provides: "Toggle favorite server action"
      exports: ["toggleFavorite"]
    - path: "src/modules/social/actions/comments.ts"
      provides: "Post comment with profanity check"
      exports: ["postComment"]
    - path: "src/modules/social/actions/reactions.ts"
      provides: "Record accumulated reaction via RPC"
      exports: ["recordReaction"]
    - path: "src/components/profile/avatar-upload.tsx"
      provides: "Avatar upload component with preview and validation"
  key_links:
    - from: "src/modules/social/actions/comments.ts"
      to: "src/lib/moderation/profanity.ts"
      via: "import containsProfanity"
      pattern: "containsProfanity"
    - from: "src/modules/social/actions/reactions.ts"
      to: "supabase.rpc('increment_reaction')"
      via: "RPC call for atomic upsert"
      pattern: "rpc.*increment_reaction"
    - from: "src/components/profile/avatar-upload.tsx"
      to: "supabase.storage.from('avatars')"
      via: "Storage upload"
      pattern: "from.*avatars.*upload"
---

<objective>
Create the database foundation, server actions, queries, and core infrastructure for all Phase 9 social features.

Purpose: Every subsequent plan (profiles, reactions, comments, cinematic mode) depends on these database tables, server actions, and queries existing. This plan builds the full data layer and backend logic so Wave 2 plans can focus purely on UI components and integration.

Output: Migration SQL, TypeScript types, Zod validation schemas, profanity filter module, all server actions (favorites, watch history, comments, reactions, profile, report), all data queries, and avatar upload component.
</objective>

<execution_context>
@/Users/solofilms/.claude/get-shit-done/workflows/execute-plan.md
@/Users/solofilms/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-social-engagement/09-RESEARCH.md
@src/db/types.ts
@src/db/schema.sql
@src/lib/validations/creator.ts
@src/modules/creator/actions/follow.ts
@src/modules/creator/actions/profile.ts
@src/components/profile/follow-button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration, TypeScript types, and validation schemas</name>
  <files>
    supabase/migrations/00000000000007_social_engagement.sql
    src/db/types.ts
    src/db/schema.sql
    src/lib/validations/social.ts
  </files>
  <action>
Create migration `00000000000007_social_engagement.sql` with:

1. **episode_comments table:**
   - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
   - `episode_id UUID NOT NULL REFERENCES public.episodes(id) ON DELETE CASCADE`
   - `user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE`
   - `content TEXT NOT NULL CHECK (char_length(content) <= 300)`
   - `timestamp_seconds INTEGER NOT NULL CHECK (timestamp_seconds >= 0)`
   - `is_flagged BOOLEAN NOT NULL DEFAULT false`
   - `created_at TIMESTAMPTZ NOT NULL DEFAULT now()`
   - Index on `(episode_id, timestamp_seconds)` for replay queries
   - RLS: SELECT for all (published episode comments are public), INSERT for authenticated users, UPDATE/DELETE for comment author

2. **episode_reactions table:**
   - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
   - `episode_id UUID NOT NULL REFERENCES public.episodes(id) ON DELETE CASCADE`
   - `timestamp_seconds INTEGER NOT NULL CHECK (timestamp_seconds >= 0)`
   - `emoji TEXT NOT NULL`
   - `count INTEGER NOT NULL DEFAULT 1 CHECK (count > 0)`
   - `created_at TIMESTAMPTZ NOT NULL DEFAULT now()`
   - `UNIQUE (episode_id, timestamp_seconds, emoji)`
   - Index on `(episode_id)` for per-episode queries
   - RLS: SELECT for all, no direct INSERT/UPDATE (handled via RPC)

3. **favorites table:**
   - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
   - `user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE`
   - `series_id UUID NOT NULL REFERENCES public.series(id) ON DELETE CASCADE`
   - `created_at TIMESTAMPTZ NOT NULL DEFAULT now()`
   - `UNIQUE (user_id, series_id)`
   - RLS: SELECT for all (public favorites), INSERT/DELETE for owner (`auth.uid() = user_id`)

4. **watch_history table:**
   - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
   - `user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE`
   - `episode_id UUID NOT NULL REFERENCES public.episodes(id) ON DELETE CASCADE`
   - `progress_seconds INTEGER NOT NULL DEFAULT 0`
   - `completed BOOLEAN NOT NULL DEFAULT false`
   - `last_watched_at TIMESTAMPTZ NOT NULL DEFAULT now()`
   - `UNIQUE (user_id, episode_id)`
   - RLS: SELECT/INSERT/UPDATE for owner only (`auth.uid() = user_id`)

5. **ALTER profiles:**
   - `ADD COLUMN watch_history_public BOOLEAN NOT NULL DEFAULT false`

6. **increment_reaction RPC function:**
   ```sql
   CREATE OR REPLACE FUNCTION increment_reaction(
     p_episode_id UUID,
     p_timestamp_seconds INTEGER,
     p_emoji TEXT
   ) RETURNS VOID AS $$
   BEGIN
     INSERT INTO public.episode_reactions (episode_id, timestamp_seconds, emoji, count)
     VALUES (p_episode_id, p_timestamp_seconds, p_emoji, 1)
     ON CONFLICT (episode_id, timestamp_seconds, emoji)
     DO UPDATE SET count = episode_reactions.count + 1;
   END;
   $$ LANGUAGE plpgsql SECURITY DEFINER;
   ```
   Grant execute to authenticated role.

7. **avatars storage bucket:**
   - Create bucket `avatars` (public)
   - RLS: SELECT for all (public avatars), INSERT/UPDATE/DELETE for owner where `(storage.foldername(name))[1] = auth.uid()::text`

Update `src/db/types.ts` with new interfaces:
- `EpisodeComment` (row type)
- `EpisodeReaction` (row type)
- `Favorite` (row type)
- `WatchHistoryEntry` (row type)
- Update `Profile` interface to include `watch_history_public: boolean`

Update `src/db/schema.sql` with the migration content as reference.

Create `src/lib/validations/social.ts` with Zod v4 schemas:
- `commentSchema`: content (string, 1-300 chars, trimmed), timestampSeconds (number, int, >= 0)
- `profileUpdateSchema`: displayName (string, 2-50 chars, trimmed), watchHistoryPublic (boolean, optional)
- `reportSchema`: contentType (enum: "comment" | "series" | "episode"), contentId (string uuid), reason (string, 10-500 chars, trimmed)
- Export `SocialFormState` type matching existing `CreatorFormState` pattern: `{ success: boolean; message: string; errors?: Record<string, string[]> }`
  </action>
  <verify>
Run `pnpm build` to confirm TypeScript compiles. Verify migration file exists and contains all 4 tables, ALTER, RPC, and storage bucket. Verify types.ts has new interfaces. Verify validations/social.ts exports schemas.
  </verify>
  <done>
Migration SQL defines episode_comments, episode_reactions, favorites, watch_history tables with RLS, increment_reaction RPC, avatars storage bucket. TypeScript types and Zod validation schemas are available for all downstream plans.
  </done>
</task>

<task type="auto">
  <name>Task 2: Profanity filter, server actions, and data queries</name>
  <files>
    src/lib/moderation/profanity.ts
    src/modules/social/actions/favorites.ts
    src/modules/social/actions/watch-history.ts
    src/modules/social/actions/comments.ts
    src/modules/social/actions/reactions.ts
    src/modules/social/actions/profile.ts
    src/modules/social/actions/report.ts
    src/modules/social/queries/get-user-favorites.ts
    src/modules/social/queries/get-watch-history.ts
    src/modules/social/queries/get-episode-comments.ts
    src/modules/social/queries/get-episode-reactions.ts
    src/modules/social/queries/get-user-activity.ts
  </files>
  <action>
**First install obscenity:**
```bash
pnpm add obscenity
```

**Create `src/lib/moderation/profanity.ts`:**
```typescript
import {
  RegExpMatcher,
  TextCensor,
  englishDataset,
  englishRecommendedTransformers,
} from "obscenity";

const matcher = new RegExpMatcher({
  ...englishDataset.build(),
  ...englishRecommendedTransformers,
});
const censor = new TextCensor();

export function containsProfanity(text: string): boolean {
  return matcher.hasMatch(text);
}

export function censorText(text: string): string {
  const matches = matcher.getAllMatches(text);
  return censor.applyTo(text, matches);
}
```

**Server Actions (all follow existing Server Actions + Zod + createClient pattern):**

1. `src/modules/social/actions/favorites.ts` ‚Äî `toggleFavorite(seriesId: string)`:
   - Auth check (require user)
   - Check if favorite exists for (user_id, series_id)
   - If exists: DELETE (unfavorite), if not: INSERT (favorite)
   - Revalidate `/series/[slug]` and `/profile/favorites`
   - Return `SocialFormState`

2. `src/modules/social/actions/watch-history.ts` ‚Äî `recordWatchProgress(episodeId: string, progressSeconds: number, completed: boolean)`:
   - Auth check (require user)
   - Upsert into watch_history: ON CONFLICT (user_id, episode_id) DO UPDATE SET progress_seconds, completed, last_watched_at = now()
   - No revalidation needed (background tracking)
   - Return void (fire-and-forget from client)

3. `src/modules/social/actions/comments.ts` ‚Äî `postComment(formData: FormData)`:
   - Auth check (require user)
   - Parse with commentSchema (content, timestampSeconds) + episodeId from formData
   - Run `containsProfanity(content)` ‚Äî if true, return error: "Comment contains inappropriate language"
   - Basic spam check: reject if content is all-caps and > 10 chars, reject if 3+ repeated chars in a row (e.g., "aaaaaa")
   - INSERT into episode_comments
   - Revalidate episode page
   - Return `SocialFormState`

4. `src/modules/social/actions/reactions.ts` ‚Äî `recordReaction(episodeId: string, timestampSeconds: number, emoji: string)`:
   - Auth check (require user)
   - Validate emoji is in curated set: ["üî•", "‚ù§Ô∏è", "üòÇ", "üò≠", "üòÆ", "üëè", "üíØ"]
   - Call `supabase.rpc("increment_reaction", { p_episode_id, p_timestamp_seconds, p_emoji })`
   - Return void (fire-and-forget from client)

5. `src/modules/social/actions/profile.ts` ‚Äî `updateViewerProfile(formData: FormData)`:
   - Auth check (require user)
   - Parse with profileUpdateSchema (displayName, watchHistoryPublic)
   - UPDATE profiles SET display_name, watch_history_public WHERE id = user.id
   - Revalidate profile pages
   - Return `SocialFormState`

   Also: `uploadAvatar(formData: FormData)`:
   - Auth check (require user)
   - Get file from formData, validate type (image/jpeg, image/png, image/webp) and size (< 2MB)
   - Upload to `avatars` bucket at path `${user.id}/avatar.${ext}` with upsert: true
   - Get public URL, UPDATE profiles SET avatar_url WHERE id = user.id
   - Revalidate profile pages
   - Return `SocialFormState`

6. `src/modules/social/actions/report.ts` ‚Äî `reportContent(formData: FormData)`:
   - Auth check (require user)
   - Parse with reportSchema
   - For now, flag the content: if contentType is "comment", UPDATE episode_comments SET is_flagged = true
   - Show toast confirmation
   - Return `SocialFormState`

**Data Queries (all use React.cache wrapper like existing patterns):**

1. `get-user-favorites.ts` ‚Äî `getUserFavorites(userId: string)`:
   - SELECT from favorites JOIN series (title, slug, thumbnail_url, genre) JOIN profiles (display_name) WHERE user_id = userId
   - ORDER BY created_at DESC

2. `get-watch-history.ts` ‚Äî `getWatchHistory(userId: string)`:
   - SELECT from watch_history JOIN episodes (title, episode_number) JOIN seasons!inner JOIN series!inner (title, slug, thumbnail_url) WHERE user_id = userId
   - ORDER BY last_watched_at DESC

3. `get-episode-comments.ts` ‚Äî `getEpisodeComments(episodeId: string)`:
   - SELECT from episode_comments JOIN profiles (display_name, avatar_url) WHERE episode_id = episodeId AND is_flagged = false
   - ORDER BY timestamp_seconds ASC
   - Return pre-bucketed Map<number, Comment[]> keyed by timestamp_seconds for O(1) lookup during playback

4. `get-episode-reactions.ts` ‚Äî `getEpisodeReactions(episodeId: string)`:
   - SELECT from episode_reactions WHERE episode_id = episodeId
   - ORDER BY timestamp_seconds ASC
   - Return pre-bucketed Map<number, Array<{emoji, count}>> for O(1) lookup during playback

5. `get-user-activity.ts` ‚Äî `getUserActivity(userId: string)`:
   - Fetch recent comments (last 20) with episode/series info
   - Fetch recent reactions (last 20) with episode/series info
   - Fetch followed creators (from existing followers table) with profile info
   - Return combined activity object

Export the curated emoji list as a constant: `REACTION_EMOJIS = ["üî•", "‚ù§Ô∏è", "üòÇ", "üò≠", "üòÆ", "üëè", "üíØ"]` from reactions.ts for reuse in picker UI.
  </action>
  <verify>
Run `pnpm build` to confirm all server actions and queries compile. Verify `obscenity` is in package.json dependencies. Verify profanity.ts exports containsProfanity and censorText. Verify all 6 action files and 5 query files exist under src/modules/social/.
  </verify>
  <done>
All server actions (favorites, watch-history, comments with profanity check, reactions with RPC, profile update with avatar upload, report) and all data queries (favorites, watch history, episode comments bucketed by timestamp, episode reactions bucketed by timestamp, user activity feed) are functional and ready for UI integration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Avatar upload component</name>
  <files>
    src/components/profile/avatar-upload.tsx
  </files>
  <action>
Create `src/components/profile/avatar-upload.tsx` as a client component:

- Display current avatar using Radix UI Avatar component (existing in codebase) with initials fallback using the existing `getInitials()` pattern from community-feed.tsx
- File input (hidden) triggered by clicking the avatar or an "Upload Photo" button
- Client-side validation: file type (image/jpeg, image/png, image/webp), file size (< 2MB)
- Preview: show selected image before upload using `URL.createObjectURL(file)`
- On confirm: call `uploadAvatar` server action from `src/modules/social/actions/profile.ts`
- Show loading state during upload using `useTransition`
- Toast feedback via `sonner` on success/error
- Props: `currentAvatarUrl: string | null`, `displayName: string`
- Cleanup: `URL.revokeObjectURL` on unmount or after upload

Style with Tailwind:
- Circular avatar (w-24 h-24 on mobile, w-32 h-32 on desktop)
- Hover overlay with camera icon (lucide-react Camera icon)
- Border: ring-2 ring-brand-yellow/20 on hover
  </action>
  <verify>
Run `pnpm build` to confirm the component compiles. Verify avatar-upload.tsx exists and imports uploadAvatar from the actions module.
  </verify>
  <done>
Avatar upload component renders current avatar with initials fallback, validates file type/size client-side, previews selected image, calls uploadAvatar server action, and provides toast feedback. Ready for use in profile settings pages.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds with no TypeScript errors
2. Migration file contains all 4 tables, ALTER statement, RPC function, and avatars storage bucket
3. `obscenity` appears in package.json dependencies
4. All files listed in files_modified exist on disk
5. TypeScript types include EpisodeComment, EpisodeReaction, Favorite, WatchHistoryEntry
6. Profanity filter correctly identifies profanity via containsProfanity()
</verification>

<success_criteria>
- Database migration defines complete social engagement schema
- All server actions compile and follow existing patterns (auth check, Zod validation, Supabase CRUD)
- Profanity filter uses obscenity library with English dataset and recommended transformers
- Avatar upload component handles file validation, preview, and storage upload
- Data queries return pre-bucketed maps for timestamp-synced comment and reaction replay
- All code follows existing codebase conventions (Server Actions, Zod v4, createClient, React.cache)
</success_criteria>

<output>
After completion, create `.planning/phases/09-social-engagement/09-01-SUMMARY.md`
</output>
