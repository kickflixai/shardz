---
phase: 01-foundation-app-shell
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - supabase/config.toml
  - supabase/migrations/00000000000001_create_content_schema.sql
  - supabase/seed.sql
  - src/db/schema.sql
  - src/db/types.ts
autonomous: true

must_haves:
  truths:
    - "Database schema defines Series > Seasons > Episodes hierarchy with foreign keys"
    - "Episodes are constrained to 60-180 seconds duration via CHECK constraint"
    - "Published seasons are constrained to 8-70 published episodes via trigger function"
    - "Row Level Security is enabled on all content tables with public read for published content"
    - "Profiles table extends Supabase auth.users with role-based access"
  artifacts:
    - path: "supabase/migrations/00000000000001_create_content_schema.sql"
      provides: "Full content hierarchy schema migration"
      contains: "CREATE TABLE public.series"
    - path: "supabase/config.toml"
      provides: "Supabase CLI project configuration"
      contains: "project_id"
    - path: "src/db/schema.sql"
      provides: "Reference copy of the database schema for documentation"
      contains: "CREATE TABLE"
    - path: "src/db/types.ts"
      provides: "TypeScript type definitions for database tables"
      contains: "Series"
  key_links:
    - from: "public.episodes"
      to: "public.seasons"
      via: "REFERENCES public.seasons(id) ON DELETE CASCADE"
      pattern: "REFERENCES public.seasons"
    - from: "public.seasons"
      to: "public.series"
      via: "REFERENCES public.series(id) ON DELETE CASCADE"
      pattern: "REFERENCES public.series"
    - from: "public.series"
      to: "public.profiles"
      via: "FOREIGN KEY (creator_id) REFERENCES public.profiles(id)"
      pattern: "REFERENCES public.profiles"
    - from: "public.episodes CHECK"
      to: "duration_seconds"
      via: "CHECK (duration_seconds >= 60 AND duration_seconds <= 180)"
      pattern: "CHECK.*duration_seconds"
    - from: "enforce_season_episode_count trigger"
      to: "public.seasons"
      via: "BEFORE UPDATE trigger on status = published"
      pattern: "enforce_season_episode_count"
---

<objective>
Create the database schema for the MicroShort content hierarchy (Series > Seasons > Episodes) with Supabase CLI migrations, enforcing business rules at the database level via CHECK constraints and trigger functions.

Purpose: The content hierarchy is the data backbone of the entire platform. Every feature (browsing, player, payments, creator dashboard) queries these tables. Getting the schema right in Phase 1 prevents costly migrations later.
Output: A Supabase migration that creates all content tables with constraints, RLS policies, indexes, and a TypeScript type definitions file.
</objective>

<execution_context>
@/Users/solofilms/.claude/get-shit-done/workflows/execute-plan.md
@/Users/solofilms/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-app-shell/01-RESEARCH.md
@.planning/phases/01-foundation-app-shell/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Supabase and create content hierarchy migration</name>
  <files>
    supabase/config.toml
    supabase/migrations/00000000000001_create_content_schema.sql
    supabase/seed.sql
  </files>
  <action>
1. Initialize Supabase in the project:
   ```bash
   supabase init
   ```
   This creates `supabase/config.toml` and the `supabase/migrations/` directory.

2. Create the migration file at `supabase/migrations/00000000000001_create_content_schema.sql` with the FULL schema from RESEARCH.md "Database Schema: Content Hierarchy" section. The migration must include ALL of the following:

   **Enums:**
   - `genre` enum: drama, comedy, thriller, sci-fi, horror, romance, action, documentary, behind-the-scenes, music, sports
   - `content_status` enum: draft, processing, ready, published, archived

   **Tables:**
   - `public.series`: id (UUID PK), slug (UNIQUE TEXT), title, description, genre, thumbnail_url, trailer_url, creator_id (FK to profiles), status (content_status DEFAULT 'draft'), is_featured (BOOLEAN DEFAULT false), view_count (INTEGER DEFAULT 0), created_at, updated_at
   - `public.seasons`: id (UUID PK), series_id (FK CASCADE), season_number, title, description, price_cents (nullable, CHECK > 0 if set), status, created_at, updated_at. UNIQUE(series_id, season_number).
   - `public.episodes`: id (UUID PK), season_id (FK CASCADE), episode_number, title, description, duration_seconds (nullable -- set by Mux webhook later), mux_asset_id, mux_playback_id, thumbnail_url, subtitle_url, status, created_at, updated_at. UNIQUE(season_id, episode_number). CHECK(duration_seconds IS NULL OR (duration_seconds >= 60 AND duration_seconds <= 180)).
   - `public.profiles`: id (UUID PK, FK to auth.users CASCADE), username (UNIQUE), display_name, avatar_url, role (TEXT CHECK IN viewer/creator/admin DEFAULT 'viewer'), bio, created_at, updated_at.

   **Foreign key added after profiles exists:**
   - `ALTER TABLE public.series ADD CONSTRAINT fk_series_creator FOREIGN KEY (creator_id) REFERENCES public.profiles(id)`

   **Trigger function for season episode count (8-70 on publish):**
   - `check_season_episode_count()` function checks episode count when season status changes to 'published'
   - Raises exception if count < 8 or > 70
   - CREATE TRIGGER `enforce_season_episode_count` BEFORE UPDATE ON public.seasons

   **Row Level Security:**
   - Enable RLS on all 4 tables
   - Public SELECT on series, seasons, episodes WHERE status = 'published'
   - Public SELECT on profiles (always visible)
   - Creators can ALL on own series (WHERE creator_id = auth.uid())
   - Creators can ALL on seasons/episodes in their series (subquery check)
   - Users can ALL on own profile (WHERE id = auth.uid())

   **Indexes:**
   - idx_series_genre (genre WHERE published)
   - idx_series_creator (creator_id)
   - idx_series_featured (is_featured WHERE published)
   - idx_seasons_series (series_id)
   - idx_episodes_season (season_id)
   - idx_profiles_role (role)

   **updated_at trigger:**
   - `update_updated_at()` function sets `NEW.updated_at = now()`
   - Applied BEFORE UPDATE on series, seasons, episodes, profiles

3. Create an empty `supabase/seed.sql` file with a comment:
   ```sql
   -- Seed data will be added in Phase 8 (Mock Data)
   -- For now, use the Supabase dashboard or API to create test data
   ```

4. Validate the migration SQL syntax by starting Supabase locally (requires Docker):
   ```bash
   supabase start
   supabase db reset
   ```
   If Docker is not available, validate by reviewing the SQL manually and ensuring all references are correctly ordered (profiles before series FK, series before seasons FK, etc.). If `supabase start` fails due to Docker, note it as a non-blocking issue -- the migration SQL is still valid and will work when pushed to a remote Supabase project.
  </action>
  <verify>
    `cat supabase/migrations/00000000000001_create_content_schema.sql` contains CREATE TABLE for series, seasons, episodes, profiles. `grep "CHECK.*duration_seconds" supabase/migrations/*` confirms episode duration constraint. `grep "check_season_episode_count" supabase/migrations/*` confirms season episode count trigger. If Docker is available: `supabase db reset` completes without errors.
  </verify>
  <done>Supabase is initialized with config.toml. The migration file contains the complete content hierarchy schema with all tables, enums, CHECK constraints, trigger functions, RLS policies, and indexes. If Docker is available, `supabase db reset` applies the migration successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types and reference schema documentation</name>
  <files>
    src/db/types.ts
    src/db/schema.sql
  </files>
  <action>
1. Create `src/db/types.ts` with hand-written TypeScript types matching the database schema. These types will be used throughout the application until we set up auto-generation from Supabase in a later phase. Define:

   ```typescript
   // Database enums
   export type Genre =
     | "drama" | "comedy" | "thriller" | "sci-fi" | "horror"
     | "romance" | "action" | "documentary" | "behind-the-scenes"
     | "music" | "sports";

   export type ContentStatus = "draft" | "processing" | "ready" | "published" | "archived";

   export type UserRole = "viewer" | "creator" | "admin";

   // Database row types
   export interface Series {
     id: string;
     slug: string;
     title: string;
     description: string | null;
     genre: Genre;
     thumbnail_url: string | null;
     trailer_url: string | null;
     creator_id: string;
     status: ContentStatus;
     is_featured: boolean;
     view_count: number;
     created_at: string;
     updated_at: string;
   }

   export interface Season {
     id: string;
     series_id: string;
     season_number: number;
     title: string | null;
     description: string | null;
     price_cents: number | null;
     status: ContentStatus;
     created_at: string;
     updated_at: string;
   }

   export interface Episode {
     id: string;
     season_id: string;
     episode_number: number;
     title: string;
     description: string | null;
     duration_seconds: number | null;
     mux_asset_id: string | null;
     mux_playback_id: string | null;
     thumbnail_url: string | null;
     subtitle_url: string | null;
     status: ContentStatus;
     created_at: string;
     updated_at: string;
   }

   export interface Profile {
     id: string;
     username: string | null;
     display_name: string | null;
     avatar_url: string | null;
     role: UserRole;
     bio: string | null;
     created_at: string;
     updated_at: string;
   }

   // Insert types (omit auto-generated fields)
   export type SeriesInsert = Omit<Series, "id" | "created_at" | "updated_at" | "view_count"> & {
     id?: string;
     view_count?: number;
   };

   export type SeasonInsert = Omit<Season, "id" | "created_at" | "updated_at"> & {
     id?: string;
   };

   export type EpisodeInsert = Omit<Episode, "id" | "created_at" | "updated_at"> & {
     id?: string;
   };

   export type ProfileInsert = Omit<Profile, "created_at" | "updated_at"> & {
     role?: UserRole;
   };

   // Update types (all fields optional except id)
   export type SeriesUpdate = Partial<Omit<Series, "id" | "created_at" | "updated_at">>;
   export type SeasonUpdate = Partial<Omit<Season, "id" | "created_at" | "updated_at">>;
   export type EpisodeUpdate = Partial<Omit<Episode, "id" | "created_at" | "updated_at">>;
   export type ProfileUpdate = Partial<Omit<Profile, "id" | "created_at" | "updated_at">>;
   ```

2. Copy the migration SQL to `src/db/schema.sql` as a reference document. Add a header comment:
   ```sql
   -- MicroShort Database Schema Reference
   -- This file is a COPY of the Supabase migration for documentation.
   -- The source of truth is supabase/migrations/
   -- Do NOT edit this file directly. Edit the migration and copy here.
   ```
   Then paste the full migration SQL below the header.

3. Verify the types compile: `pnpm tsc --noEmit` (or `pnpm build`).
  </action>
  <verify>
    `pnpm build` succeeds (types compile). `grep "export interface Series" src/db/types.ts` confirms Series type exists. `grep "export type Genre" src/db/types.ts` confirms Genre enum type exists. `grep "SeriesInsert" src/db/types.ts` confirms insert types exist.
  </verify>
  <done>TypeScript types for all database tables exist in src/db/types.ts with row, insert, and update variants. Reference schema.sql exists in src/db/ with a clear "source of truth" header pointing to supabase/migrations/.</done>
</task>

</tasks>

<verification>
1. `supabase/config.toml` exists (Supabase CLI initialized)
2. Migration file contains CREATE TABLE for series, seasons, episodes, profiles
3. `grep "CHECK.*duration_seconds.*60.*180" supabase/migrations/*` confirms episode duration constraint
4. `grep "check_season_episode_count" supabase/migrations/*` confirms season episode count trigger
5. `grep "ENABLE ROW LEVEL SECURITY" supabase/migrations/*` returns 4 results (one per table)
6. `grep "export interface Series" src/db/types.ts` confirms TypeScript types exist
7. `pnpm build` succeeds with the new types
8. If Docker available: `supabase db reset` completes without SQL errors
</verification>

<success_criteria>
- The migration SQL creates the complete content hierarchy: series, seasons, episodes, profiles
- CHECK constraints enforce episode duration (60-180s) and positive pricing
- Trigger function enforces 8-70 episodes per published season
- RLS is enabled with public read for published content and creator self-management
- TypeScript types match the database schema exactly
- The project still builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-app-shell/01-02-SUMMARY.md`
</output>
