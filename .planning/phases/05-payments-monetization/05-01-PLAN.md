---
phase: 05-payments-monetization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/stripe/client.ts
  - src/lib/stripe/checkout.ts
  - src/lib/stripe/prices.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/app/api/checkout/route.ts
  - src/modules/purchases/queries/get-user-purchases.ts
  - src/modules/purchases/types.ts
  - src/db/types.ts
  - src/db/schema.sql
  - supabase/migrations/00000000000003_purchases_and_pricing.sql
autonomous: true
user_setup:
  - service: stripe
    why: "Payment processing for season unlocks"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key (use test mode key sk_test_...)"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Run `stripe listen --forward-to localhost:3000/api/webhooks/stripe` in terminal -> copies webhook signing secret (whsec_...)"
    dashboard_config:
      - task: "Create Stripe account (if needed)"
        location: "https://dashboard.stripe.com/register"
      - task: "Install Stripe CLI for local webhook testing"
        location: "https://docs.stripe.com/stripe-cli"

must_haves:
  truths:
    - "Stripe SDK is available for server-side payment operations"
    - "Database can store purchases, price tiers, and payout records"
    - "Webhook handler receives Stripe checkout.session.completed events and records purchases"
    - "Checkout API creates Stripe sessions for single-season and all-seasons bundle purchases"
    - "Application can query whether a user has purchased a specific season"
  artifacts:
    - path: "src/lib/stripe/client.ts"
      provides: "Stripe SDK singleton"
      contains: "new Stripe"
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook endpoint"
      exports: ["POST"]
    - path: "src/app/api/checkout/route.ts"
      provides: "Checkout session creation"
      exports: ["POST"]
    - path: "supabase/migrations/00000000000003_purchases_and_pricing.sql"
      provides: "purchases, price_tiers, payout_records tables + profile extensions"
      contains: "CREATE TABLE public.purchases"
    - path: "src/modules/purchases/queries/get-user-purchases.ts"
      provides: "Purchase check for episode access"
      exports: ["hasUserPurchasedSeason", "getUserSeasonPurchases"]
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "supabase purchases table"
      via: "admin client insert on checkout.session.completed"
      pattern: "from.*purchases.*insert"
    - from: "src/app/api/checkout/route.ts"
      to: "src/lib/stripe/checkout.ts"
      via: "createCheckoutSession helper"
      pattern: "createCheckoutSession"
    - from: "src/app/api/checkout/route.ts"
      to: "supabase seasons table"
      via: "fetch season price and metadata for Stripe session"
      pattern: "from.*seasons.*select"
---

<objective>
Set up Stripe payment infrastructure: SDK client, database schema for purchases and pricing, webhook handler for payment fulfillment, checkout session API for single-season and bundle purchases, and purchase query utilities.

Purpose: This plan establishes the server-side payment backbone that the paywall UI (Plan 02) and Connect payouts (Plan 03) will build on. Without this foundation, no payment flow can function.

Output: Stripe SDK wired, 3 new DB tables (purchases, price_tiers, payout_records), webhook handler recording purchases, checkout API creating Stripe sessions, and purchase query functions ready for access control integration.
</objective>

<execution_context>
@/Users/solofilms/.claude/get-shit-done/workflows/execute-plan.md
@/Users/solofilms/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-payments-monetization/05-RESEARCH.md

# Existing patterns to follow:
@src/lib/mux/client.ts                    # Singleton SDK client pattern
@src/app/api/webhooks/mux/route.ts         # Webhook handler pattern (raw body, signature verification, admin client)
@src/lib/supabase/admin.ts                 # Admin client for webhook context
@src/db/types.ts                           # TypeScript DB types pattern
@src/db/schema.sql                         # Schema documentation mirror
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stripe SDK, database migration, and TypeScript types</name>
  <files>
    src/lib/stripe/client.ts
    src/lib/stripe/prices.ts
    src/modules/purchases/types.ts
    src/db/types.ts
    src/db/schema.sql
    supabase/migrations/00000000000003_purchases_and_pricing.sql
    package.json
  </files>
  <action>
    1. Install stripe: `pnpm add stripe`

    2. Create `src/lib/stripe/client.ts` -- Stripe SDK singleton following the mux/client.ts pattern:
       ```typescript
       import Stripe from 'stripe';
       export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
         typescript: true,
       });
       ```

    3. Create `supabase/migrations/00000000000003_purchases_and_pricing.sql` with:
       - `price_tiers` table: id (UUID PK), label (TEXT NOT NULL), price_cents (INTEGER NOT NULL CHECK > 0), stripe_price_id (TEXT), sort_order (INTEGER NOT NULL DEFAULT 0), is_active (BOOLEAN DEFAULT true), created_at. RLS enabled, SELECT policy for active tiers visible to everyone.
       - Seed 5 initial price tiers: Budget ($2.99), Standard ($4.99), Premium ($7.99), Deluxe ($9.99), Blockbuster ($14.99).
       - ALTER `seasons` table: ADD COLUMN `price_tier_id UUID REFERENCES public.price_tiers(id)`.
       - ALTER `profiles` table: ADD COLUMN `stripe_account_id TEXT`, ADD COLUMN `stripe_onboarding_complete BOOLEAN NOT NULL DEFAULT false`.
       - ALTER `series` table: ADD COLUMN `bundle_discount_percent INTEGER DEFAULT 15 CHECK (bundle_discount_percent IS NULL OR (bundle_discount_percent >= 0 AND bundle_discount_percent <= 50))`.
       - `purchases` table: id (UUID PK), user_id (UUID FK profiles NOT NULL), season_id (UUID FK seasons NOT NULL), creator_id (UUID FK profiles NOT NULL), stripe_session_id (TEXT UNIQUE NOT NULL), stripe_payment_intent_id (TEXT), stripe_charge_id (TEXT), amount_cents (INTEGER NOT NULL), platform_fee_cents (INTEGER NOT NULL), creator_share_cents (INTEGER NOT NULL), status (TEXT CHECK IN ('completed', 'refunded') DEFAULT 'completed'), transferred (BOOLEAN DEFAULT false), stripe_transfer_id (TEXT), created_at. UNIQUE constraint on (user_id, season_id). RLS enabled: users can SELECT own purchases, creators can SELECT purchases of their content. Indexes on user_id, season_id, creator_id, and untransferred by creator_id.
       - `payout_records` table: id (UUID PK), creator_id (UUID FK profiles NOT NULL), purchase_id (UUID FK purchases NOT NULL), stripe_transfer_id (TEXT NOT NULL), amount_cents (INTEGER NOT NULL), status (TEXT CHECK IN ('completed', 'failed') DEFAULT 'completed'), created_at. RLS enabled: creators can SELECT own payouts. Index on creator_id.

    4. Create `src/lib/stripe/prices.ts`:
       - Export `PRICE_TIERS` constant array with the 5 tier options: `{ label, priceCents, displayPrice }`.
       - Export `formatPrice(cents: number): string` helper (e.g., 499 -> "$4.99").
       - Export `calculateBundlePrice(seasonPrices: number[], discountPercent: number): number` -- sums individual season prices and applies discount.

    5. Create `src/modules/purchases/types.ts`:
       - Export `Purchase` interface matching the purchases table schema.
       - Export `PriceTier` interface matching the price_tiers table.
       - Export `PayoutRecord` interface matching the payout_records table.
       - Export `PurchaseStatus = 'completed' | 'refunded'` type.

    6. Update `src/db/types.ts`:
       - Add `Purchase`, `PriceTier`, `PayoutRecord` interfaces (Row types).
       - Add insert/update type aliases following existing Omit/Partial pattern.
       - Add `stripe_account_id` and `stripe_onboarding_complete` to `Profile` interface.
       - Add `price_tier_id` to `Season` interface.
       - Add `bundle_discount_percent` to `Series` interface.

    7. Update `src/db/schema.sql` to mirror the migration (append new tables after the existing schema).
  </action>
  <verify>
    - `pnpm ls stripe` shows stripe installed
    - Migration file exists at `supabase/migrations/00000000000003_purchases_and_pricing.sql`
    - `src/lib/stripe/client.ts` exports `stripe`
    - `src/db/types.ts` includes Purchase, PriceTier, PayoutRecord types
    - `pnpm build` succeeds (type checking passes)
  </verify>
  <done>
    Stripe SDK installed and configured as singleton. Database migration creates purchases, price_tiers, and payout_records tables with RLS policies, indexes, and seed data. TypeScript types defined for all new tables. Price utility functions available for formatting and bundle calculation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Stripe webhook handler, checkout API, and purchase queries</name>
  <files>
    src/app/api/webhooks/stripe/route.ts
    src/app/api/checkout/route.ts
    src/lib/stripe/checkout.ts
    src/modules/purchases/queries/get-user-purchases.ts
  </files>
  <action>
    1. Create `src/app/api/webhooks/stripe/route.ts`:
       - Follow the Mux webhook pattern (request.text() for raw body, signature verification, admin client).
       - Use `stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK_SECRET!)` for verification.
       - Handle `checkout.session.completed` event:
         a. Check `session.payment_status === 'paid'`.
         b. Extract metadata: `season_id`, `user_id`, `creator_id`, `series_id`, `purchase_type` (single or bundle).
         c. If `purchase_type === 'bundle'`: metadata contains `season_ids` (comma-separated). Insert a purchase row for EACH season in the bundle.
         d. Idempotency: check if purchase already exists by `stripe_session_id` before inserting.
         e. Retrieve PaymentIntent with `expand: ['latest_charge']` to get charge_id for future transfers.
         f. Insert purchase record(s) with: user_id, season_id, creator_id, stripe_session_id, stripe_payment_intent_id, stripe_charge_id, amount_cents (for bundles: divide total proportionally by each season's price), platform_fee_cents (20%), creator_share_cents (80%), status='completed'.
       - Return 200 OK for all events (acknowledge unhandled events).

    2. Create `src/lib/stripe/checkout.ts`:
       - Export `createSeasonCheckoutSession(params)` helper:
         Params: `{ seasonId, seriesSlug, userId, userEmail, seasonTitle, seriesTitle, priceCents, creatorId, seriesId }`
         Creates a Stripe Checkout Session in payment mode with:
         - `line_items`: one item with `price_data` (currency: 'usd', unit_amount from priceCents, product_data with series+season name)
         - `customer_email`: userEmail
         - `metadata`: { season_id, series_id, user_id, creator_id, purchase_type: 'single' }
         - `success_url`: `${NEXT_PUBLIC_APP_URL}/checkout/success?session_id={CHECKOUT_SESSION_ID}`
         - `cancel_url`: `${NEXT_PUBLIC_APP_URL}/series/${seriesSlug}`
         Returns the session URL.
       - Export `createBundleCheckoutSession(params)` helper:
         Params: `{ seasonIds, seasonPrices, seriesSlug, userId, userEmail, seriesTitle, totalPriceCents, creatorId, seriesId }`
         Creates session with:
         - `line_items`: one item for the bundle (product_data: "Unlock all seasons of {seriesTitle}")
         - `metadata`: { season_ids: ids joined by comma, series_id, user_id, creator_id, purchase_type: 'bundle' }
         - Same success/cancel URLs as single.

    3. Create `src/app/api/checkout/route.ts` (POST):
       - Authenticate user via `createClient()` + `getUser()`. Return 401 if not authenticated.
       - Accept JSON body: `{ seasonId?: string, seriesSlug: string, purchaseType: 'single' | 'bundle' }`
       - For `purchaseType === 'single'`:
         a. Fetch season with price_cents, title, plus series title, creator_id, slug via join.
         b. Check if user already has a completed purchase for this season -> return 409 "Already purchased".
         c. Call `createSeasonCheckoutSession(...)`.
         d. Return `{ url: session.url }`.
       - For `purchaseType === 'bundle'`:
         a. Fetch all seasons for the series (by series slug) with their price_cents.
         b. Filter out seasons user has already purchased.
         c. If no unpurchased seasons remain -> return 409 "Already purchased all seasons".
         d. Calculate bundle price: sum of remaining season prices minus bundle_discount_percent from series table.
         e. Call `createBundleCheckoutSession(...)`.
         f. Return `{ url: session.url }`.

    4. Create `src/modules/purchases/queries/get-user-purchases.ts`:
       - Export `hasUserPurchasedSeason(userId: string, seasonId: string): Promise<boolean>`:
         Query purchases table for matching user_id + season_id with status='completed', return boolean.
       - Export `getUserSeasonPurchases(userId: string, seasonIds: string[]): Promise<Set<string>>`:
         Query purchases for user_id IN seasonIds with status='completed', return Set of purchased season IDs.
         This is for efficiently checking multiple seasons at once (series page).
       - Both use the cookie-based server client (not admin) since they run in authenticated user context.
  </action>
  <verify>
    - `pnpm build` succeeds
    - Webhook route exports POST
    - Checkout route exports POST
    - `get-user-purchases.ts` exports `hasUserPurchasedSeason` and `getUserSeasonPurchases`
    - No TypeScript errors in any new files
  </verify>
  <done>
    Stripe webhook handler processes checkout.session.completed events and records purchases with idempotency. Checkout API creates Stripe sessions for both single-season and bundle purchases with proper authentication and duplicate guards. Purchase query utilities are ready for episode access control integration in Plan 02.
  </done>
</task>

</tasks>

<verification>
- `pnpm build` passes with no errors
- `stripe` package is in dependencies
- All new files compile and export correctly
- Migration file has correct SQL syntax (visually inspect CREATE TABLE, ALTER TABLE, policies, indexes)
- Webhook handler uses `request.text()` (not `.json()`) and `stripe.webhooks.constructEvent`
- Checkout route checks for authenticated user and existing purchases before creating sessions
- Purchase query functions use Supabase server client (cookie-based, not admin)
</verification>

<success_criteria>
- Stripe SDK is installed and a singleton client is available at `@/lib/stripe/client`
- Database migration creates purchases, price_tiers, payout_records tables with RLS and indexes
- Webhook handler at `/api/webhooks/stripe` verifies Stripe signatures, handles checkout.session.completed, and inserts purchase records idempotently
- Checkout API at `/api/checkout` creates Stripe Checkout sessions for single-season and all-seasons bundle purchases
- `hasUserPurchasedSeason` and `getUserSeasonPurchases` functions query the purchases table
- All TypeScript types reflect the new database schema
</success_criteria>

<output>
After completion, create `.planning/phases/05-payments-monetization/05-01-SUMMARY.md`
</output>
